# Map Tailscale header to auth bypass flag
# If Tailscale-User-Login header is present, user is authenticated via Tailscale
map $http_tailscale_user_login $auth_bypass {
    default "off";
    "~.+"   "off";  # Any non-empty value means Tailscale auth
}

# Satisfy directive: allow if EITHER Tailscale auth OR basic auth passes
# When behind Tailscale Serve/Funnel, the header is present and we skip basic auth
map $http_tailscale_user_login $auth_basic_realm {
    default "Muni Console";
    "~.+"   "off";  # Disable basic auth prompt when Tailscale header present
}

server {
    listen 80;
    server_name localhost;
    root /usr/share/nginx/html;
    index index.html;

    # =========================================================================
    # Authentication
    # =========================================================================
    # Uses Tailscale identity when available, falls back to basic auth
    # Set CONSOLE_PASSWORD env var to enable password protection

    auth_basic $auth_basic_realm;
    auth_basic_user_file /etc/nginx/.htpasswd;

    # SPA routing: serve index.html for all non-API routes
    location / {
        try_files $uri $uri/ /index.html;
    }

    # Cache static assets
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2)$ {
        expires 1y;
        add_header Cache-Control "public, immutable";
    }

    # Health check (no auth required)
    location /health {
        auth_basic off;
        access_log off;
        return 200 "OK\n";
        add_header Content-Type text/plain;
    }

    # Auth info endpoint - returns current user info
    location /api/auth/me {
        default_type application/json;

        # If Tailscale header present, return that identity
        if ($http_tailscale_user_login) {
            return 200 '{"authenticated":true,"provider":"tailscale","user":"$http_tailscale_user_login","name":"$http_tailscale_user_name"}';
        }

        # Otherwise, basic auth was used
        return 200 '{"authenticated":true,"provider":"basic","user":"$remote_user"}';
    }

    # =========================================================================
    # API Reverse Proxies
    # =========================================================================
    # All upstreams use dynamic DNS resolution so nginx starts even if
    # backend services aren't running yet. Docker's internal DNS (127.0.0.11)
    # resolves container names at request time.

    # Discovery service (rover registration, fleet status)
    location ~ ^/api/discovery/(.*)$ {
        resolver 127.0.0.11 valid=30s;
        set $discovery_upstream discovery:4860;
        proxy_pass http://$discovery_upstream/$1$is_args$args;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Authenticated-User $http_tailscale_user_login$remote_user;
        proxy_read_timeout 86400;
    }

    # GPS status service (base station status)
    location ~ ^/api/gps/(.*)$ {
        resolver 127.0.0.11 valid=30s;
        set $gps_upstream gps-status:4880;
        proxy_pass http://$gps_upstream/$1$is_args$args;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Authenticated-User $http_tailscale_user_login$remote_user;
        proxy_read_timeout 86400;
    }

    # Map API service (3D map serving)
    location ~ ^/api/maps/(.*)$ {
        resolver 127.0.0.11 valid=30s;
        set $mapapi_upstream map-api:4870;
        proxy_pass http://$mapapi_upstream/$1$is_args$args;
        proxy_http_version 1.1;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Authenticated-User $http_tailscale_user_login$remote_user;
    }

    # Grafana dashboards (served from /grafana/ subpath)
    # Grafana is configured with GF_SERVER_SERVE_FROM_SUB_PATH=true, so we preserve the /grafana/ prefix
    # Grafana has its own authentication, so we disable nginx auth here
    location ~ ^/grafana(.*)$ {
        auth_basic off;
        resolver 127.0.0.11 valid=30s;
        set $grafana_upstream grafana:3000;
        proxy_pass http://$grafana_upstream/grafana$1$is_args$args;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Authenticated-User $http_tailscale_user_login$remote_user;
    }

    # Gzip compression
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml text/javascript;
    gzip_min_length 1000;
}
